//! Encryption related to the STS server

use std::mem::size_of;

use aes::cipher::{
    block_padding::{UnpadError, ZeroPadding},
    BlockDecryptMut as _, KeyIvInit as _,
};
use num_traits::ToPrimitive as _;
use rand::SeedableRng as _;
use rc4::{consts::U128, KeyInit as _, StreamCipher as _};
use rsa::{hazmat, traits::PublicKeyParts, BigUint, RsaPrivateKey};
use sha2::{Digest, Sha256};

const CLIENT_RAND_LEN: usize = 0x20;
const SERVER_RAND_LEN: usize = 0x20;
const MD5_LEN: usize = 0x10;
const PREMASET_SECRET_LEN: usize = 0x30;

/// [PublicKeyBlob Reference](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-mqqb/ade9efde-3ec8-4e47-9ae9-34b64d8081bb)
/// [rfc](https://www.rfc-editor.org/rfc/rfc8017.txt)
#[derive(Debug)]
struct PublicKeyBlob {
    magic: u32,
    e: BigUint,
    bits: usize,
    n: BigUint,
}

#[allow(dead_code)]
impl PublicKeyBlob {
    const HEADER_LEN: usize = 12;

    fn from_slice(raw: &[u8]) -> Result<Self, &'static str> {
        if raw.len() < 12 {
            return Err("Invalid PublicKeyBlob Header Size");
        }
        let mut ptr = 0;
        let magic = u32::from_le_bytes(
            raw[ptr..ptr + size_of::<u32>()].try_into().unwrap(),
        );
        ptr += size_of::<u32>();
        let e = BigUint::from_bytes_le(&raw[ptr..ptr + size_of::<u32>()]);
        ptr += size_of::<u32>();

        let bits = u32::from_le_bytes(
            raw[ptr..ptr + size_of::<u32>()].try_into().unwrap(),
        ) as usize;
        ptr += size_of::<u32>();

        if raw.len() < (Self::HEADER_LEN + bits) {
            return Err("Invalid PublicKeyBlob bits len");
        }
        let n = BigUint::from_bytes_le(&raw[ptr..ptr + bits as usize]);

        Ok(Self { magic, e, bits, n })
    }

    fn from_public_key_parts(key: &impl PublicKeyParts) -> Self {
        Self {
            magic: 4,
            e: key.e().clone(),
            bits: key.size(),
            n: key.n().clone(),
        }
    }

    fn serialise(&self, buf: &mut [u8]) -> usize {
        let mut len = 0;
        buf[len..len + 4].clone_from_slice(&self.magic.to_le_bytes());
        len += 4;

        let e = self.e.to_u32().unwrap();
        buf[len..len + 4].clone_from_slice(&e.to_le_bytes());
        len += 4;

        let bits = self.bits as u32;
        buf[len..len + 4].clone_from_slice(&bits.to_le_bytes());
        len += 4;

        buf[len..len + self.bits].clone_from_slice(&self.n.to_bytes_le());
        len += self.bits;
        len
    }
}

pub fn aes256_cbc_decrypt<'a>(
    key: &[u8; 0x20],
    inout: &'a mut [u8],
) -> Result<&'a [u8], UnpadError> {
    let iv = [0u8; 0x10];
    let aes = cbc::Decryptor::<aes::Aes256>::new_from_slices(key, &iv).unwrap();
    aes.decrypt_padded_inout_mut::<ZeroPadding>(inout.into())
}

/// RSA without padding and additional randomness
pub struct Rsa {
    private_key: RsaPrivateKey,
}

impl Rsa {
    pub fn new(bits: usize) -> Self {
        let mut rng = rand::thread_rng();
        let private_key = RsaPrivateKey::new(&mut rng, bits).unwrap();
        Self { private_key }
    }

    pub fn new_from_seed(bits: usize, seed: u64) -> Self {
        let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
        let private_key = RsaPrivateKey::new(&mut rng, bits).unwrap();
        Self { private_key }
    }

    pub fn serialise_as_public_key_blob(&self, buf: &mut [u8]) -> usize {
        let pub_key = PublicKeyBlob::from_public_key_parts(&self.private_key);
        pub_key.serialise(buf)
    }

    /// Takes the input buffer cipher_text and stores the result in plain_text
    pub fn decrypt(&self, cipher_text: &[u8]) -> Vec<u8> {
        hazmat::rsa_decrypt(
            None::<&mut rand::rngs::StdRng>,
            &self.private_key,
            &BigUint::from_bytes_le(cipher_text),
        )
        .unwrap()
        .to_bytes_le()
    }
}

pub struct Krypt {
    pub rsa: Rsa,
    pub rc4: Option<Rc4>,
    pub server_rand: [u8; SERVER_RAND_LEN],
    pub client_rand: [u8; CLIENT_RAND_LEN],
}

pub struct Rc4 {
    encrypt_key: rc4::Rc4<U128>,
    decrypt_key: rc4::Rc4<U128>,
}

impl Rc4 {
    const KEY_LEN: usize = 0x80;

    pub fn new(
        client_key: [u8; Self::KEY_LEN],
        server_key: [u8; Self::KEY_LEN],
    ) -> Self {
        Self {
            encrypt_key: rc4::Rc4::new(&client_key.into()),
            decrypt_key: rc4::Rc4::new(&server_key.into()),
        }
    }

    pub fn decrypt(&mut self, mut ciphertext: &mut [u8]) {
        self.decrypt_key.apply_keystream(&mut ciphertext);
    }

    pub fn encrypt(&mut self, mut plaintext: &mut [u8]) {
        self.encrypt_key.apply_keystream(&mut plaintext);
    }
}

/// The last step to creating RC4 keys used for continuing the
/// STS auth session, premaster_secret must have the prefix 0x0303, maybe this
/// is a primative checksum? Premaster Secret must be decrypted using AES CBC
/// block decryption
pub fn generate_rc4_keys(
    server_rand: [u8; SERVER_RAND_LEN],
    client_rand: [u8; CLIENT_RAND_LEN],
    premaster_secret: [u8; PREMASET_SECRET_LEN],
) -> ([u8; Rc4::KEY_LEN], [u8; Rc4::KEY_LEN]) {
    const FIRST_ROUNDS: usize = 3;
    const SECOND_ROUNDS: usize = 18;
    const SHA_INPUT_LEN: usize =
        CLIENT_RAND_LEN + SERVER_RAND_LEN + PREMASET_SECRET_LEN + 0x01;

    let mut md5s = [[0u8; 0x10]; FIRST_ROUNDS];

    let mut keys = [0u8; 0x120];
    for i in 0..FIRST_ROUNDS {
        let mut ptr = i + 1;

        for ii in 0..=i {
            keys[ii] = (i as u8) + b'B';
        }

        keys[ptr..ptr + premaster_secret.len()]
            .copy_from_slice(&premaster_secret);
        ptr += premaster_secret.len();
        keys[ptr..ptr + client_rand.len()].copy_from_slice(&client_rand);
        ptr += client_rand.len();
        keys[ptr..ptr + server_rand.len()].copy_from_slice(&server_rand);

        let mut hasher: Sha256 = Digest::new();
        hasher.update(&keys[..SHA_INPUT_LEN + i]);
        let sha256_hash = hasher.finalize();

        let mut md5_input = [0u8; 80];
        let mut ptr = 0;
        md5_input[ptr..ptr + premaster_secret.len()]
            .copy_from_slice(&premaster_secret);
        ptr += premaster_secret.len();
        md5_input[ptr..ptr + sha256_hash.len()].copy_from_slice(&sha256_hash);
        let md5_digest = md5::compute(md5_input);

        md5s[i].copy_from_slice(md5_digest.as_slice());
    }

    let mut buf = [0u8; 0x200];
    for i in 0..SECOND_ROUNDS {
        let mut ptr = i + 1;

        for ii in 0..=i {
            buf[ii] = (i as u8) + b'B';
        }

        for md5 in md5s {
            buf[ptr..ptr + MD5_LEN].copy_from_slice(&md5);
            ptr += MD5_LEN;
        }
        buf[ptr..ptr + server_rand.len()].copy_from_slice(&server_rand);
        ptr += server_rand.len();
        buf[ptr..ptr + client_rand.len()].copy_from_slice(&client_rand);

        let mut hasher: Sha256 = Digest::new();
        hasher.update(&buf[..SHA_INPUT_LEN + i]);
        let sha256_hash = hasher.finalize();

        let mut md5_input = [0u8; 80];
        let mut ptr = 0;
        for md5 in md5s {
            md5_input[ptr..ptr + MD5_LEN].copy_from_slice(&md5);
            ptr += MD5_LEN;
        }
        md5_input[ptr..ptr + sha256_hash.len()].copy_from_slice(&sha256_hash);

        let md5_digest = md5::compute(md5_input);
        let start = i * MD5_LEN;
        keys[start..start + MD5_LEN].copy_from_slice(md5_digest.as_slice());
    }

    let keys = &keys[0x20..];
    let mut client_key = [0u8; Rc4::KEY_LEN];
    client_key.copy_from_slice(&keys[Rc4::KEY_LEN..]);

    let mut server_key = [0u8; Rc4::KEY_LEN];
    server_key.copy_from_slice(&keys[..Rc4::KEY_LEN]);

    (client_key, server_key)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_gen_rc4() {
        let server_rand = [
            0x66, 0x6F, 0x6F, 0x66, 0x6F, 0x6F, 0x66, 0x6F, 0x6F, 0x66, 0x6F,
            0x6F, 0x66, 0x6F, 0x6F, 0x66, 0x6F, 0x6F, 0x66, 0x6F, 0x6F, 0x66,
            0x6F, 0x6F, 0x66, 0x6F, 0x6F, 0x66, 0x6F, 0x6F, 0x66, 0x6F,
        ];
        let client_rand = [
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
        ];
        let premaster_secret = [
            0x03, 0x03, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A,
        ];

        let (client_key, server_key) =
            generate_rc4_keys(server_rand, client_rand, premaster_secret);

        let expected = (
            [
                0xAA, 0x4D, 0x23, 0x50, 0xFB, 0x85, 0x64, 0x31, 0x93, 0xE1,
                0xDF, 0xBF, 0x65, 0x9E, 0xF4, 0xAE, 0x9D, 0x82, 0x41, 0x6B,
                0x8D, 0xC3, 0xEE, 0x57, 0x2C, 0x63, 0xED, 0x06, 0x12, 0x6F,
                0xFE, 0xD9, 0xF2, 0xEC, 0x94, 0x7E, 0x5F, 0xEA, 0x0C, 0x3F,
                0xD9, 0x5F, 0xE4, 0x89, 0x22, 0x8C, 0x81, 0x05, 0x3D, 0x5E,
                0xAF, 0x54, 0x2D, 0xA2, 0x28, 0xDB, 0xC3, 0x25, 0xA1, 0xDC,
                0x4B, 0xBB, 0x94, 0x06, 0x95, 0x1D, 0x6B, 0x9F, 0x47, 0xA2,
                0x10, 0xC1, 0x2E, 0x93, 0x7D, 0x65, 0x89, 0x45, 0x7A, 0xB9,
                0xF7, 0x98, 0x3E, 0x77, 0xE0, 0x3E, 0x63, 0xE4, 0x4A, 0xB9,
                0xB9, 0x7A, 0xD7, 0x47, 0x49, 0xF3, 0xB4, 0xD9, 0x61, 0x69,
                0x67, 0x5E, 0x64, 0xBA, 0x64, 0x55, 0x95, 0x76, 0x0A, 0x93,
                0x82, 0x3D, 0x77, 0xFA, 0x3F, 0x95, 0x23, 0x4A, 0xA3, 0x24,
                0x40, 0x5F, 0xB6, 0x40, 0xEC, 0x06, 0xF4, 0x17,
            ],
            [
                0x0B, 0x91, 0x7A, 0xDE, 0xD9, 0xC3, 0x8D, 0x1E, 0x8D, 0x38,
                0x81, 0x3E, 0xE6, 0xB4, 0xE7, 0x9C, 0x2C, 0xDF, 0x7C, 0xFA,
                0x35, 0x59, 0xC2, 0xDF, 0x20, 0x65, 0x39, 0xA5, 0x1B, 0xA4,
                0xF8, 0x94, 0x47, 0xDE, 0xF7, 0xD0, 0x5D, 0xE7, 0xBA, 0x09,
                0xDC, 0xF1, 0xD1, 0x40, 0x26, 0x62, 0xE1, 0xEE, 0xC0, 0x76,
                0x68, 0x7E, 0x69, 0x35, 0x8B, 0xE0, 0x17, 0x4D, 0xB0, 0x35,
                0xD8, 0x9B, 0xF0, 0xAD, 0x9C, 0x54, 0x64, 0x10, 0x5D, 0xF5,
                0x4C, 0xF1, 0x64, 0x40, 0x29, 0x82, 0xCF, 0x41, 0xFD, 0xD0,
                0x92, 0x9F, 0x0A, 0xD3, 0x9A, 0x4C, 0x23, 0x2F, 0x98, 0xB8,
                0xB2, 0x8D, 0x29, 0x98, 0x54, 0xB2, 0x42, 0x32, 0x7D, 0xE4,
                0xA8, 0x99, 0x85, 0xE9, 0xED, 0x49, 0xAC, 0x38, 0xA0, 0xF6,
                0x80, 0xD5, 0xB8, 0xF8, 0x1E, 0x6A, 0x8E, 0x9B, 0xC7, 0x23,
                0xB3, 0x40, 0x6C, 0x16, 0xEA, 0x4C, 0x3A, 0xF4,
            ],
        );
        assert_eq!(server_key, expected.1);
        assert_eq!(client_key, expected.0);
    }

    #[test]
    fn decrypt_aes() {
        let key = [0x1A; 0x20];
        let mut plain_text = [
            0x65, 0xBF, 0x44, 0xA, 0x5C, 0x75, 0x2B, 0x5D, 0x67, 0x3A, 0x1E,
            0xD1, 0x50, 0x58, 0x2E, 0xFD, 0x71, 0xA1, 0xAA, 0x9, 0x4D, 0x80,
            0x93, 0xC2, 0x2B, 0xA6, 0x86, 0x90, 0xBF, 0x0, 0x43, 0x26, 0xFF,
            0x2E, 0xD7, 0xB, 0x50, 0x7D, 0xE5, 0xAE, 0xAF, 0xEE, 0xAD, 0x63,
            0x9B, 0x79, 0xE6, 0x53,
        ];
        aes256_cbc_decrypt(&key, &mut plain_text);

        let expected = [
            0x03, 0x03, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
            0x1A, 0x1A, 0x1A, 0x1A,
        ];
        assert_eq!(expected, plain_text);
    }

    #[test]
    fn test_generate_rsa() {
        let cipher_text = [
            0x7B, 0xCF, 0xBA, 0x8B, 0x42, 0x81, 0x23, 0x48, 0x6F, 0x5A, 0x65,
            0xC3, 0x52, 0x9A, 0xA1, 0x7F, 0xD3, 0x4C, 0x34, 0x3F, 0x12, 0x54,
            0x78, 0x24, 0xEE, 0xB1, 0x64, 0xE5, 0x50, 0xB8, 0x7F, 0x09, 0xA7,
            0x44, 0xEA, 0x1F, 0x1E, 0x6D, 0xF7, 0xB3, 0x1C, 0x09, 0x53, 0xB5,
            0xD4, 0xC2, 0x45, 0x72, 0xE7, 0xFF, 0x75, 0x99, 0xF2, 0x34, 0x8C,
            0x1F, 0x2D, 0xD9, 0x4D, 0xBC, 0x7A, 0xF8, 0x11, 0xBF, 0x81, 0x81,
            0xF0, 0x60, 0xA1, 0x38, 0x32, 0xE5, 0x8D, 0xBA, 0xDB, 0x71, 0x89,
            0x56, 0x99, 0x05, 0x7C, 0x09, 0x33, 0x6E, 0x02, 0x0A, 0xBB, 0x0F,
            0x11, 0x78, 0x30, 0xF7, 0x5A, 0x69, 0xD8, 0xB6, 0xAE, 0x07, 0xD2,
            0x9F, 0x49, 0x72, 0x76, 0x66, 0x44, 0x9C, 0x6A, 0x4F, 0x9E, 0xFD,
            0xF4, 0xAE, 0x1F, 0xF7, 0xBC, 0xE7, 0x6A, 0x88, 0xC3, 0xF2, 0xBF,
            0x1B, 0x53, 0xC6, 0x95, 0x86, 0x2B, 0x12, 0xCB, 0x48, 0xB7, 0x5E,
            0x03, 0xCD, 0x13, 0x6F, 0x11, 0x39, 0x97, 0x79, 0x56, 0x41, 0xCE,
            0x85, 0xCA, 0xFD, 0x07, 0xAA, 0x9C, 0x88, 0xC8, 0x5C, 0xC3, 0x4C,
            0x3D, 0x66, 0x3A, 0x0A, 0x58, 0xE2, 0x5A, 0x04, 0xDF, 0xAA, 0x19,
            0x82, 0x8D, 0xCF, 0xB3, 0x30, 0x3D, 0x0F, 0x1F, 0x5E, 0xE8, 0xFF,
            0x6A, 0x94, 0xCC, 0x62, 0x8D, 0xFF, 0xDE, 0x68, 0xD7, 0x32, 0xC4,
            0x5C, 0x4B, 0xC5, 0x0C, 0x0C, 0x1F, 0x71, 0x99, 0xB2, 0x75, 0x4D,
            0x45, 0x1D, 0xB1, 0x1F, 0xF9, 0x13, 0x1C, 0x7D, 0x34, 0x46, 0x2D,
            0x54, 0x39, 0xE3, 0x70, 0xE1, 0xED, 0xD1, 0x0B, 0xCB, 0xAA, 0x06,
            0x0D, 0x0B, 0xFE, 0x7A, 0x20, 0xBC, 0x9B, 0x72, 0x5A, 0x37, 0xFD,
            0xEA, 0xC1, 0xB0, 0x63, 0x45, 0x42, 0x52, 0xAE, 0x25, 0xB5, 0x97,
            0x35, 0xA7, 0x66, 0x1F, 0xC4, 0x89, 0xC9, 0xF0, 0xC2, 0x97, 0xAF,
            0xFD, 0x4A, 0x28,
        ];

        let rsa = Rsa::new_from_seed(0x100 * 8, 0x13371337);
        let mut buf = [0u8; 1024];
        let len = rsa.serialise_as_public_key_blob(&mut buf);

        let plain_text = rsa.decrypt(&cipher_text);
        assert_eq!(plain_text, [0x1Au8; 0x20]);
    }
}
